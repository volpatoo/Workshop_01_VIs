
## Vegetation index (VI) extractions using RGB orthomosaic images</p></p>
Author: Leonardo Volpato</p>
Date: Last compiled on 16 December, 2022</p>

---------------------------------------------

### About this analysis 

The present analysis aims to perform the VIs extractions from the RGB images aka orthomosaic. </p>
Data source: Dry Beans Breeding Program - MSU. </p>
Principal Investigator: [Dr. Francisco Gomez](https://www.canr.msu.edu/people/francisco-gomez) 


<p align="center">
    <img src="https://raw.githubusercontent.com/volpatoo/images/master/readme/Pipeline_RGB_VIs2.jpg" width="100%" height="100%">
</p>

---------------------------------------------

## Resources

* [Basic pipeline](#pipeVI)
* [Getting started - Complete data set](#startdata)
   * [Running the loops](#Runloop)
   * [Adjusting the results and saving](#savingdata)


---------------------------------------------


## Setting up the working directory

```{r}
rm(list=ls())
my.path <- dirname(rstudioapi::getActiveDocumentContext()$path)
setwd(my.path)
```

## Load and install necessary Packages

```{r message=TRUE, warning=FALSE, results='asis',echo = F}
library("sp")
library("sf")
#library("raster")
library("terra")
library("rgdal")
library("ggplot2")
library("agricolae")
library("reshape2")
library("devtools")
library("ggrepel")
library("lme4")
library("plyr")
library("DescTools")
library("doParallel")
library('parallel')
library('foreach')
library('maptools')
library('spatialEco')
library('attempt')
library('igraph')
library('config')
library("BiocManager")
library("EBImage")
library("FIELDimageR")
library("dplyr")
# BiocManager::install("EBImage")
# install.packages("git2r")
# devtools::install_github("filipematias23/FIELDimageR", dependencies=FALSE)
summary(report::report(sessionInfo()))

```


```{r}
# if(!require(pacman)) install.packages(pacman)
# 
# pacman::p_load(
#                     sp,
#                     #raster,
#                     terra,
#                     rgdal,
#                     ggplot2,
#                     agricolae,
#                     reshape2,
#                     devtools,
#                     ggrepel,
#                     lme4,
#                     plyr,
#                     DescTools,
#                     doParallel,
#                     parallel,
#                     foreach,
#                     maptools,
#                     spatialEco,
#                     attempt,
#                     igraph,
#                     config,
#                     BiocManager,
#                     EBImage,
#                     FIELDimageR
# ) 
```


# Basic pipeline

## Setting the work directories
| A example soybean files will be used to perform this introduction pipeline. As reference see [Volpato et al. 2021](G:\Shared drives\Bean_Lab\Volpato\R_script\Example_drone_data_soy)
* The example data contain: 2 orthomosaic and a shapefile with 48 plots in total.

### Folder directory containing the orthomosaics

```{r}
dir_ortho <- "/MOSAIC"
dir_ortho <- paste(my.path,dir_ortho, sep="")
print(dir_ortho)
```

### Folder directory containing the shapefiles

```{r}
folder_shp <- "./Shapefile"
```

## Getting the files

```{r}
imgFiles <-list.files(path = dir_ortho, pattern="*.tif$",full.names = T) #get the Orthosaics. 
imgFiles #Files that their name ends in group1.tif (Change all file names to otimization)
#> [1] "G:\\Shared drives\\Bean_Lab\\Volpato\\R_script\\Example_drone_data_soy/WA_2018_08_15.tif"
#> [2] "G:\\Shared drives\\Bean_Lab\\Volpato\\R_script\\Example_drone_data_soy/WA_2018_08_23.tif"

imgFiles_name <-list.files(path = dir_ortho, pattern="*.tif$") # Aux file names
imgFiles_name <- gsub(".tif", "", imgFiles_name, ignore.case = FALSE, perl = FALSE, fixed = TRUE, useBytes = FALSE) # Removing the extension
imgFiles_name
#> [1] "WA_2018_08_15" "WA_2018_08_23"
```


## Loading and Reading the plots Shapefile

```{r}
# Loading the shape files
layer_prefix_shp <- "Export_Output" # name with the .shp extension
## Read the plots Shapefile
#indPlots <- readOGR(dsn = folder_shp, layer = layer_prefix_shp)
indPlots <- vect( folder_shp, layer = layer_prefix_shp)
#> OGR data source with driver: ESRI Shapefile 
#> Source: "G:\Shared drives\Bean_Lab\Volpato\R_script\Example_drone_data_soy", layer: "Export_Output"
#> with 48 features
#> It has 9 fields
## Polygon plot ID list from the shapefiles
names(indPlots)
#> [1] "Range2"     "Row2"       "Test"       "Entry"      "MNPlot"     "RM"        
#> [7] "RM_list"    "RepNo"      "MaturityDa"
```

## Getting the RGB bands

```{r}
#img_ortho <- imgFiles[1]
img.rgb.1 <- rast(imgFiles[1])
img.rgb.1
#> class      : RasterStack 
#> dimensions : 1582, 836, 1322552, 4  (nrow, ncol, ncell, nlayers)
#> resolution : 0.02535, 0.02535  (x, y)
#> extent     : 457926.1, 457947.2, 4880222, 4880262  (xmin, xmax, ymin, ymax)
#> crs        : +proj=utm +zone=15 +datum=WGS84 +units=m +no_defs 
#> names      : WA_2018_08_15.1, WA_2018_08_15.2, WA_2018_08_15.3, WA_2018_08_15.4 
#> min values :              36,              40,               1,             255 
#> max values :             254,             252,             225,             255
```

## Ploting the field maps and shapefile
```{r}
plotRGB(img.rgb.1)

plot(indPlots,add=T,col="red") # merge the external shp file and orthomosaic
```

![](VI_extractions_01_files/figure-html/unnamed-chunk-6-1.png)<!-- -->

## Reducing the image resoution if necessary

```{r}
img.rgb.2<-aggregate(img.rgb.1, fact=4) ## reducing the resoluation. Using high numbers for fact is not desired. 
```

## Cropping the plot image

```{r}
plot_crop_idx_1 <- crop(img.rgb.1,ext(indPlots[1,]))
```

## Plotting the plot image

```{r}
plotRGB(plot_crop_idx_1)
```

![](VI_extractions_01_files/figure-html/unnamed-chunk-9-1.png)<!-- -->

## Building vegetation indices
* The R package `FIELDimageR` will be used to perform this step. Referene: [Filipe Matias](https://github.com/OpenDroneMap/FIELDimageR/blob/master/README.md)


```{r}
img.index <- fieldIndex(mosaic = plot_crop_idx_1, index = c("BI", "GLI", "HI", "NGRDI", "BGI", "VARI", "SCI")) 
#> [1] "4 layers available"
```

![](VI_extractions_01_files/figure-html/unnamed-chunk-10-1.png)<!-- -->

```{r}
plot(img.index$NGRDI)
```

![](VI_extractions_01_files/figure-html/unnamed-chunk-10-2.png)<!-- -->

## Removing the soil
* The R package `FIELDimageR` will be used to perform this step.
* Choosing the best index to build a mask for RGB
* This is a trick analysis to run, but this criteria is up to the research to pick one threshold and VIs


```{r}
EX.Mask1 <- fieldMask(mosaic = plot_crop_idx_1, index = "NGRDI", cropValue = 0.05, cropAbove = F)
#> [1] "4 layers available"
```

![](VI_extractions_01_files/figure-html/unnamed-chunk-11-1.png)<!-- -->

```{r}

EX.Mask2 <- fieldMask(mosaic = plot_crop_idx_1, index = "GLI", cropValue = 0.05, cropAbove = F)
#> [1] "4 layers available"
```

![](VI_extractions_01_files/figure-html/unnamed-chunk-11-2.png)<!-- -->

```{r}

EX.Mask3 <- fieldMask(mosaic = plot_crop_idx_1, index = "HI", cropValue = 0.6, cropAbove = T) #all values above the cropValue will be accounted to make the mask.
#> [1] "4 layers available"
```

![](VI_extractions_01_files/figure-html/unnamed-chunk-11-3.png)<!-- -->

```{r}

EX.Mask4 <- fieldMask(mosaic = plot_crop_idx_1, index = "HI", cropValue = 0.8, cropAbove = T)
#> [1] "4 layers available"
```

![](VI_extractions_01_files/figure-html/unnamed-chunk-11-4.png)<!-- -->

```{r}
EX.Mask5 <- fieldMask(mosaic = plot_crop_idx_1, index = "HI", cropValue = 0.6, cropAbove = T) ## This model will be select to perform the analysis
#> [1] "4 layers available"
```

![](VI_extractions_01_files/figure-html/unnamed-chunk-11-5.png)<!-- -->

##  Building vegetation indices


```{r}
#Investigating the raw image plot
img.index.hi <- fieldIndex(mosaic = plot_crop_idx_1, index = c("HI") )
#> [1] "4 layers available"
```

![](VI_extractions_01_files/figure-html/unnamed-chunk-12-1.png)<!-- -->

```{r}
hist(img.index.hi$HI) # Image segmentation start from 0.7 (soil and plants)
```

![](VI_extractions_01_files/figure-html/unnamed-chunk-12-2.png)<!-- -->

```{r}

#Investigating the clean image plot
img.index.hi.clean <- fieldIndex(mosaic = EX.Mask5$newMosaic, index = c("HI") )
#> [1] "4 layers available"
```

![](VI_extractions_01_files/figure-html/unnamed-chunk-12-3.png)<!-- -->

```{r}
hist(img.index.hi.clean$HI) # Image segmentation start from 0.7 (soil and plants)
```

![](VI_extractions_01_files/figure-html/unnamed-chunk-12-4.png)<!-- -->


## Orthomosaic image


```{r}
ortho.index.hi.clean<- fieldIndex(mosaic = img.rgb.1, index = c("HI"))
#> [1] "4 layers available"
```

![](VI_extractions_01_files/figure-html/unnamed-chunk-13-1.png)<!-- -->

```{r}
#dev.off()

ortho.HI.RemSoil<- fieldMask(mosaic = img.rgb.1, Red = 1, Green = 2, Blue = 3, 
                   index = "HI", cropValue = 0.7, cropAbove = T) 
#> [1] "4 layers available"
```

![](VI_extractions_01_files/figure-html/unnamed-chunk-13-2.png)<!-- -->


## Extracting the pixels values


```{r}

##Selection the VI from the clean orthomosaic
Veg.Indices<-fieldIndex(mosaic = ortho.HI.RemSoil$newMosaic,
                        index=c("GLI"))
#> [1] "4 layers available"
```

![](VI_extractions_01_files/figure-html/unnamed-chunk-14-1.png)<!-- -->

```{r}

## Read the plots Shapefile
indPlots <- readOGR(dsn = folder_shp, layer = layer_prefix_shp)
#indPlots <- read_sf(dsn = folder_shp, layer = layer_prefix_shp)

## Conf. the CRS projections
projection(indPlots)<-projection(Veg.Indices) ##Makes coordinate system of .tif with indices and without soil and .shp the same


ortho.Info1<-fieldInfo(mosaic=Veg.Indices,
                     fieldShape=indPlots,
                     n.core=10) ## Extracts all vegetation indices (layers) for each .shp file
#> [1] "Extracting: 5 layers."
#> [1] "You can speed up this step using n.core=12 or less."

VI_data<- dplyr::as_tibble(ortho.Info1$fieldShape@data)

write.csv(VI_data, "VI_data_GLI.csv",  row.names=F) 

hist(ortho.Info1$fieldShape$GLI)
```

![](VI_extractions_01_files/figure-html/unnamed-chunk-14-2.png)<!-- -->


```{r}
#names(indPlots)
### Interpolating colors: c("white","black")
fieldPlot(fieldShape=ortho.Info1$fieldShape,fieldAttribute="MaturityDa", mosaic=Veg.Indices, color=c("white","black"), alpha = 0.5)

### Interpolating colors: c("red","blue")
fieldPlot(fieldShape=ortho.Info1$fieldShape,fieldAttribute="GLI", mosaic=Veg.Indices, color=c("red","blue"), alpha = 0.5)
```
![](VI_extractions_01_files/figure-html/unnamed-chunk-15-1.png)<!-- -->

![](VI_extractions_01_files/figure-html/unnamed-chunk-15-2.png)<!-- -->

<div id="startdata" />

---------------------------------------------

# Getting started - Complete data set

This code will run across of 4 type of loops:
* Flgith date (orthomosaic) **i**
* Vegetation index (VIs) **v**
* Function of pixel value extraction **f**
* Plot ID **p**

**ATTENTION**
- This script will run using the [parallel function](https://stat.ethz.ch/R-manual/R-devel/library/parallel/doc/parallel.pdf) to improve the computer capacity, however, be aware that you computer will be dedicated only for this analysis. To avoid any crash, reduce the number of cores to -2 from your total number. \n
\n


## Setting up the working directory 

```{r}
rm(list=ls())
my.path <- dirname(rstudioapi::getActiveDocumentContext()$path)
setwd(my.path)
```

# Setting the work directories

## Folder directory containing the orthomosaics

```{r}
dir_ortho <- "G:\\Shared drives\\Bean_Lab\\Volpato\\R_script\\Example_drone_data_soy"
```

## Folder directory containing the shapefiles

```{r}
folder_shp <- "G:\\Shared drives\\Bean_Lab\\Volpato\\R_script\\Example_drone_data_soy"
```

# Getting the files

```{r}
imgFiles <-list.files(path = dir_ortho, pattern="*.tif$",full.names = T) #get the Orthosaics. 
imgFiles #Files that their name ends in group1.tif (Change all file names to otimization)
#> [1] "G:\\Shared drives\\Bean_Lab\\Volpato\\R_script\\Example_drone_data_soy/WA_2018_08_15.tif"
#> [2] "G:\\Shared drives\\Bean_Lab\\Volpato\\R_script\\Example_drone_data_soy/WA_2018_08_23.tif"

imgFiles_name <-list.files(path = dir_ortho, pattern="*.tif$") # Aux file names
imgFiles_name <- gsub(".tif", "", imgFiles_name, ignore.case = FALSE, perl = FALSE, fixed = TRUE, useBytes = FALSE) # Removing the extension
imgFiles_name
#> [1] "WA_2018_08_15" "WA_2018_08_23"
```


# Loading and Reading the plots Shapefile

```{r}
# Loading the shape files
layer_prefix_shp <- "Export_Output"
## Read the plots Shapefile
indPlots <- readOGR(dsn = folder_shp, layer = layer_prefix_shp)
#> OGR data source with driver: ESRI Shapefile 
#> Source: "G:\Shared drives\Bean_Lab\Volpato\R_script\Example_drone_data_soy", layer: "Export_Output"
#> with 48 features
#> It has 9 fields
## Polygon plot ID list from the shapefiles
names(indPlots)
#> [1] "Range2"     "Row2"       "Test"       "Entry"      "MNPlot"     "RM"        
#> [7] "RM_list"    "RepNo"      "MaturityDa"

# Subsetting plots to speed up the loop
indPlots<- indPlots[1:5,"MNPlot"]
indPlots
#> class       : SpatialPolygonsDataFrame 
#> features    : 5 
#> extent      : 457931.5, 457944.5, 4880257, 4880261  (xmin, xmax, ymin, ymax)
#> crs         : +proj=utm +zone=15 +datum=WGS84 +units=m +no_defs 
#> variables   : 1
#> names       : MNPlot 
#> min values  : 264001 
#> max values  : 264033
```

# Setting the parameters from the loop

## Plots ID

```{r}
## Data frame with plot names
Plot_ID<- as.data.frame(indPlots[,"MNPlot"])
indPlots # Plot identification propose
#> class       : SpatialPolygonsDataFrame 
#> features    : 5 
#> extent      : 457931.5, 457944.5, 4880257, 4880261  (xmin, xmax, ymin, ymax)
#> crs         : +proj=utm +zone=15 +datum=WGS84 +units=m +no_defs 
#> variables   : 1
#> names       : MNPlot 
#> min values  : 264001 
#> max values  : 264033
```

## VIs list
* The VIs list will be imported from a separated R script in order to the script maximization

```{r}
## Import the functions file
source("VIs_RGB-aux.R")

#Reading 38 VIs from RGB image
myIndex_list<- myIndex_list
myIndex_list_name<- myIndex_list_name
```

## Functions of extractions

```{r}
func_list<- c('mean', 'median','sd')
# There are many other functions (SD, VAR, Quantiles, etc)
```


## Starting the parallel function
Please, take your time and study how this function works and if this function is for you.


```{r}
gc() #Cleaning unusual memmory
#>           used  (Mb) gc trigger  (Mb) max used  (Mb)
#> Ncells 4656148 248.7    8556108 457.0  6793720 362.9
#> Vcells 6972624  53.2   27730724 211.6 54136618 413.1

# Number of cores
n.core<-detectCores() # or detectCores()

# Starting parallel
cl <- makeCluster(n.core, output = "")
registerDoParallel(cl)
getDoParWorkers()
#> [1] 12
```

<div id="Runloop" />

## Running the loops

```{r}
## Using the code inside the system time to get the total time used.
system.time(
  for(i in 1:length(imgFiles)){ #loop through images

    message("Processing ortho: ",paste(imgFiles_name[i]))
    #i.h<-aggregate(stack(imgFiles[k]), fact=aggregateCells) to reduce the image size if the case
    i.h <-  stack(imgFiles[i])
   
    for(v in 1:length(myIndex_list)){ #loop through VIs
    
      message("Using VI: ",paste(myIndex_list_name[v]))
      
      for(f in 1:length(func_list)){  #loop through extractions functions
        
        message("Using function: ",paste(func_list[f]))
      
  results<- foreach(p = 1:length(indPlots),  #loop through plots numbers
                     .packages = c("raster", "FIELDimageR"), 
                     .combine = rbind) %dopar% {
                       
    # Step 1: crop the plot from the orthomosaci
    h.c <-  crop(i.h, extent(indPlots[p,]))
    
    # Step 2: remove the soil using the HUE VI with a threshold = 0.6
    m.h <-  fieldMask(mosaic=h.c,
                           Red=1,
                           Green=2,
                           Blue=3,
                           index="HUE",
                           cropValue=0.6, #or 0.6 | 0.8
                           cropAbove=T, ## Removes any instance of soil from tif file
                           plot = FALSE) 
    
    # Step 3: Obtain the VI from the vegetation only
    Veg.Indices<-fieldIndex(mosaic = m.h$newMosaic, myIndex=myIndex_list[v],
    plot = FALSE)
    
    projection(indPlots)<-projection(Veg.Indices)
    
    # Step 4: Extraction the pixel value from each individual plot using the function 
     raster::extract(x = Veg.Indices$myIndex, y = indPlots[p,], fun = eval(parse(text = func_list[f])),  
            buffer = buffer, na.rm = T, df = T)
     
                     }
  
       results$Func<-func_list[f]
  
    # Step 5: Saving the results into a data frame with the lenght of the Plots ID
       results$ID <- 1:length(indPlots)
  
  if(f==1){results.1<-results}else{results.1<-rbind(results.1, results)}
  
      }
      
    # Step 6: Saving the vegetation index name for each function
      results.1$VIs<-myIndex_list_name[v]
  
     if(v==1){results.2<-results.1}else{results.2<-rbind(results.2, results.1)}

    }
    
    # # Step 6: Saving the vegetation index name from each function for each orthomosaic
      results.2$imgFiles_name<-imgFiles_name[i]
      
        if(i==1){results.3<-results.2}else{results.3<-rbind(results.3, results.2)}
    
  })
#>    user  system elapsed 
#>    2.48    0.42  307.19

parallel::stopCluster(cl) # Stopping the parallel function


###### the end ###########
```

<div id="savingdata" />

## Adjusting the results and saving

```{r}
as_tibble(results.3) # Saving into a table
#> # A tibble: 760 x 5
#>       ID myIndex Func   VIs       imgFiles_name
#>    <int>   <dbl> <chr>  <list>    <chr>        
#>  1     1    115. mean   <chr [1]> WA_2018_08_15
#>  2     2    118. mean   <chr [1]> WA_2018_08_15
#>  3     3    119. mean   <chr [1]> WA_2018_08_15
#>  4     4    120. mean   <chr [1]> WA_2018_08_15
#>  5     5    134. mean   <chr [1]> WA_2018_08_15
#>  6     1    114. median <chr [1]> WA_2018_08_15
#>  7     2    116. median <chr [1]> WA_2018_08_15
#>  8     3    118. median <chr [1]> WA_2018_08_15
#>  9     4    120. median <chr [1]> WA_2018_08_15
#> 10     5    134. median <chr [1]> WA_2018_08_15
#> # ... with 750 more rows

# Adjusting the data for VIs and Func columns
results.final<-pivot_wider(results.3, names_from   = c("VIs", "Func"),
                           values_from = "myIndex")

head(results.final)
#> # A tibble: 6 x 78
#>      ID imgFiles_name BI_mean BI_median BIM_mean BIM_median SCI_mean SCI_median GLI_mean
#>   <int> <chr>           <dbl>     <dbl>    <dbl>      <dbl>    <dbl>      <dbl>    <dbl>
#> 1     1 WA_2018_08_15    115.      114.     14.8       14.8  -0.0705    -0.0758    0.200
#> 2     2 WA_2018_08_15    118.      116.     15.0       14.9  -0.0606    -0.0671    0.190
#> 3     3 WA_2018_08_15    119.      118.     15.1       15.1  -0.0503    -0.0554    0.179
#> 4     4 WA_2018_08_15    120.      120.     15.2       15.2  -0.0517    -0.0576    0.172
#> 5     5 WA_2018_08_15    134.      134.     16.2       16.2  -0.0197    -0.0175    0.130
#> 6     1 WA_2018_08_23    120.      119.     15.2       15.2  -0.0564    -0.0580    0.173
#> # ... with 69 more variables: GLI_median <dbl>, HI_mean <dbl>, HI_median <dbl>,
#> #   NGRDI_mean <dbl>, NGRDI_median <dbl>, SI_mean <dbl>, SI_median <dbl>,
#> #   VARI_mean <dbl>, VARI_median <dbl>, HUE_mean <dbl>, HUE_median <dbl>,
#> #   BdivG_mean <dbl>, BdivG_median <dbl>, BCC_mean <dbl>, BCC_median <dbl>,
#> #   CIVE_mean <dbl>, CIVE_median <dbl>, COM1_mean <dbl>, COM1_median <dbl>,
#> #   COM2_mean <dbl>, COM2_median <dbl>, ExG_mean <dbl>, ExG_median <dbl>,
#> #   ExG2_mean <dbl>, ExG2_median <dbl>, ExGR_mean <dbl>, ExGR_median <dbl>, ...

# Saving
write.csv(results.final, "test01_MRF_RGB.csv", quote = F, row.names = F)
```


---------------------------------------------


# Running using a small data set 
> Recommended image size smaller than 500 MB

```{r}
##################################################################################
####################### OPTION 2 - ONLY FOR SMALL DATA SET #######################
##################################################################################

n.core<-detectCores()-0                   
# Starting parallel
cl <- makeCluster(n.core, output = "")
registerDoParallel(cl)
## reducing the resolution. Using high numbers for fact is not desired. 
## Without this parameter, there is no way to run such big data set!!!
# The rasterOptions() allows you to customize your R session (raster package): 
gc()
rasterOptions()
rasterOptions(chunksize = 1e+20)
rasterOptions(maxmemory = 1e+20)

#aggregateCells = 4 #Check it it is necessary to reduce the image size

ptm <- proc.time() #6:00 PM 1-15-2022
for(k in 1:length(imgFiles)){
  message("Removing soil from ortho: ",paste(imgFiles_name[k]))
  ##Reducing from 0.461 cm to 1.844 cm (0.461 * 4) = fact = 4
  imgFiles_2<-aggregate(stack(imgFiles[k]), fact=aggregateCells) 
  message("Reducing the image resolution ", aggregateCells, " times")
#imgFiles_2<-stack(imgFiles[k]) ## Reading the tiff file you want to process

EX1.RemSoil<-fieldMask(mosaic=imgFiles_2,
                       Red=1,
                       Green=2,
                       Blue=3,
                       index="HUE",
                       cropValue=0.7, #or 0.6 | 0.8
                       cropAbove=T, ## Removes any instance of soil from tif file
                       plot = FALSE) 

Veg.Indices<-fieldIndex(mosaic = EX1.RemSoil$newMosaic, plot = FALSE)

projection(indPlots)<-projection(Veg.Indices)

EX1.Info1<-fieldInfo(mosaic=Veg.Indices,
                     fieldShape=indPlots,
                     fun = "mean",
                     n.core=12,
                     projection = FALSE) ## Extracts all vegetation indices (layers) for each .shp file plot

EX1.Info1_data<- EX1.Info1$fieldShape@data[,15:19] # Need to change here according to the number of columns from attribute shapefile
colnames(EX1.Info1_data)<- paste(colnames(EX1.Info1_data),imgFiles_name[k],sep="_")
VIs.Table<- cbind(VIs.Table,EX1.Info1_data) #save all columns into a data frame
  
rm(Veg.Indices,EX1.Info1,EX1.Info1_data)
gc()

## 33 VIs will be used from RGB images!!!
for(v in 1:length(myIndex_list)){
  message("Using VI: ",paste(myIndex_list_name[v]))
Veg.Indices2<-fieldIndex(mosaic = EX1.RemSoil$newMosaic, plot = FALSE,
                         myIndex=myIndex_list[v])

projection(indPlots)<-projection(Veg.Indices2) ##Makes coordinate system of .tif with indices and without soil and .shp the same

EX1.Info2<-fieldInfo(mosaic=Veg.Indices2$myIndex,
                     fieldShape=indPlots,
                     fun = "mean",
                     n.core=12,
                     projection = FALSE) ## Extracts all vegetation indices (layers) for each .shp file plot

EX1.Info1_data2<- EX1.Info2$fieldShape@data[15]
colnames(EX1.Info1_data2)<- paste(myIndex_list_name[v],imgFiles_name[k], sep="_")
VIs.Table<- cbind(VIs.Table,EX1.Info1_data2) #save all columns into a data frame

rm(EX1.Info2,EX1.Info1_data2,Veg.Indices2)
gc()

}

rm(EX1.RemSoil,imgFiles_2)
}
proc.time() - ptm

data_beans_col <- as.data.frame(indPlots[,1:13])

VIs_RGB_outp <- cbind(data_beans_col, VIs.Table)

write.csv(VIs_RGB_outp, "output.csv", quote = F, row.names = F)

```


## Adjusting the data set
> This script turns columns to rows according to the VIs names and date of flights

```{r}
####################################################################################
########### Vegetation index extractions using RGB orthomosaic images ##############
####################################################################################

### Setting up the working directory 
rm(list=ls())
my.path <- dirname(rstudioapi::getActiveDocumentContext()$path)
setwd(my.path)

if(!require("pacman")) install.packages("pacman")

pacman::p_load(FIELDimageR,
               raster,
               sp,
               dplyr,
               rgdal,
               lidR,
               parallel,
               foreach,
               doParallel,
               tidyr
) 

####Change it###
dir_multispec <- "~path"

VIs.out1<- read.csv("dfname_csv")

###Get all the files to process from the WD
imgFiles <-list.files(path = dir_multispec, pattern="*.tif$",full.names = T) #get the Orthosaics. Files that their name ends in group1.tif (Change all file names to otimization)
imgFiles_name <-list.files(path = dir_multispec, pattern="*.tif$")
imgFiles_name
imgFiles

imageMulti_names_list <- imgFiles_name %>% substr( start = 1, stop = 7)

imageMulti_levels<- levels(as.factor(imageMulti_names_list))


# Taking the file names
names<- c("Blue", "Green", "NIR", "RedEdge", "Red", "HUE", "PSRI","NDVI",
          "GNDVI","RVI","NDRE","TVI","CVI","CIG","CIRE","DVI","EVI", 'Flight_Date')


for (i in 1:length(imageMulti_levels)) {

VIs.out1.sub1<-VIs.out1 %>%
  select(contains(imageMulti_levels[i]))
VIs.out1.sub1$Flight_Date<- imageMulti_levels[i]
# length(names)
# length(VIs.out1.sub1)

colnames(VIs.out1.sub1)<- c(names)

if(i==1){VIs.out1.sub2<-VIs.out1.sub1}else{VIs.out1.sub2<-rbind(VIs.out1.sub2, VIs.out1.sub1)}

}

VIs.out1.sub2 = VIs.out1.sub2 %>% select(Flight_Date, everything())
head(VIs.out1.sub2)

VIs.out1.adj<- cbind(VIs.out1[,1:13], VIs.out1.sub2)


write.csv(VIs.out1.adj, "MS_VIs_MRC_2021_median_adj.csv", quote = F, row.names = F)
```























