
## Vegetation index (VI) extractions using RGB orthomosaic images</p></p>
Author: Leonardo Volpato</p>
Date: Last compiled on 19 December, 2022</p>

---------------------------------------------

### About this analysis 

The present analysis aims to perform the VIs extractions from the RGB images aka orthomosaic. </p>
Data source: Dry Beans Breeding Program - MSU. </p>
Principal Investigator: [Dr. Francisco Gomez](https://www.canr.msu.edu/people/francisco-gomez) 


<p align="center">
    <img src="https://raw.githubusercontent.com/volpatoo/images/master/readme/Pipeline_RGB_VIs2.jpg" width="100%" height="100%">
</p>

---------------------------------------------

## Resources

* [Basic pipeline](#pipeVI)
* [Getting started - Complete data set](#startdata)
   * [Running the loops](#Runloop)
   * [Adjusting the results and saving](#savingdata)


---------------------------------------------


## Setting up the working directory

```{r}
rm(list=ls())
my.path <- dirname(rstudioapi::getActiveDocumentContext()$path)
setwd(my.path)
```

## Load and install necessary Packages

```{r message=TRUE, warning=FALSE, results='asis',echo = F}
library("sp")
library("sf")
library("raster")
library("terra")
library("rgdal")
library("ggplot2")
library("agricolae")
library("reshape2")
library("devtools")
library("ggrepel")
library("lme4")
library("plyr")
library("DescTools")
library("doParallel")
library('parallel')
library('foreach')
library('maptools')
library('spatialEco')
library('attempt')
library('igraph')
library('config')
library("BiocManager")
library("EBImage")
library("FIELDimageR")
library("dplyr")
library("tidyr")


#install.packages("tidyr")

# BiocManager::install("EBImage")
# install.packages("git2r")
# devtools::install_github("filipematias23/FIELDimageR", dependencies=FALSE)
#summary(report::report(sessionInfo()))

```


```{r}
# if(!require(pacman)) install.packages(pacman)
# 
# pacman::p_load(
#                     sp,
#                     #raster,
#                     terra,
#                     rgdal,
#                     ggplot2,
#                     agricolae,
#                     reshape2,
#                     devtools,
#                     ggrepel,
#                     lme4,
#                     plyr,
#                     DescTools,
#                     doParallel,
#                     parallel,
#                     foreach,
#                     maptools,
#                     spatialEco,
#                     attempt,
#                     igraph,
#                     config,
#                     BiocManager,
#                     EBImage,
#                     FIELDimageR,
#                     tidyr
# ) 
```


# Basic pipeline

## Setting the work directories
| A example soybean files will be used to perform this introduction pipeline. As reference see [Volpato et al. 2021](G:\Shared drives\Bean_Lab\Volpato\R_script\Example_drone_data_soy)
* The example data contain: 2 orthomosaic and a shapefile with 48 plots in total.

### Folder directory containing the orthomosaics

```{r}
dir_ortho <- "/MOSAIC"
dir_ortho <- paste(my.path,dir_ortho, sep="")
print(dir_ortho)
```

### Folder directory containing the shapefiles

```{r}
folder_shp <- "./Shapefile"
```

## Getting the files

```{r}
imgFiles <-list.files(path = dir_ortho, pattern="*.tif$",full.names = T) #get the Orthosaics. 
imgFiles #Files that their name ends in group1.tif (Change all file names to otimization)
#> [1] "G:\\Shared drives\\Bean_Lab\\Volpato\\R_script\\Example_drone_data_soy/WA_2018_08_15.tif"
#> [2] "G:\\Shared drives\\Bean_Lab\\Volpato\\R_script\\Example_drone_data_soy/WA_2018_08_23.tif"

imgFiles_name <-list.files(path = dir_ortho, pattern="*.tif$") # Aux file names
imgFiles_name <- gsub(".tif", "", imgFiles_name, ignore.case = FALSE, perl = FALSE, fixed = TRUE, useBytes = FALSE) # Removing the extension
imgFiles_name
#> [1] "WA_2018_08_15" "WA_2018_08_23"
```


## Loading and Reading the plots Shapefile

```{r}
# Loading the shape files
layer_prefix_shp <- "Export_Output" # name with the .shp extension
## Read the plots Shapefile
#indPlots <- readOGR(dsn = folder_shp, layer = layer_prefix_shp)
indPlots <- vect( folder_shp, layer = layer_prefix_shp)
#> OGR data source with driver: ESRI Shapefile 
#> Source: "G:\Shared drives\Bean_Lab\Volpato\R_script\Example_drone_data_soy", layer: "Export_Output"
#> with 48 features
#> It has 9 fields
## Polygon plot ID list from the shapefiles
names(indPlots)
#> [1] "Range2"     "Row2"       "Test"       "Entry"      "MNPlot"     "RM"        
#> [7] "RM_list"    "RepNo"      "MaturityDa"
```

## Getting the RGB bands

```{r}
#img_ortho <- imgFiles[1]
img.rgb.1 <- rast(imgFiles[1])
img.rgb.1
#> class      : RasterStack 
#> dimensions : 1582, 836, 1322552, 4  (nrow, ncol, ncell, nlayers)
#> resolution : 0.02535, 0.02535  (x, y)
#> extent     : 457926.1, 457947.2, 4880222, 4880262  (xmin, xmax, ymin, ymax)
#> crs        : +proj=utm +zone=15 +datum=WGS84 +units=m +no_defs 
#> names      : WA_2018_08_15.1, WA_2018_08_15.2, WA_2018_08_15.3, WA_2018_08_15.4 
#> min values :              36,              40,               1,             255 
#> max values :             254,             252,             225,             255
```

## Ploting the field maps and shapefile
```{r}
plotRGB(img.rgb.1)

plot(indPlots,add=T,col="red") # merge the external shp file and orthomosaic
```

## Reducing the image resoution if necessary

```{r}
img.rgb.2<-aggregate(img.rgb.1, fact=4) ## reducing the resoluation. Using high numbers for fact is not desired. 
```

## Cropping the plot image

```{r}
plot_crop_idx_1 <- crop(img.rgb.1,ext(indPlots[1,]))
```

## Plotting the plot image

```{r}
plotRGB(plot_crop_idx_1)
```

## Building vegetation indices
* The R package `FIELDimageR` will be used to perform this step. Referene: [Filipe Matias](https://github.com/OpenDroneMap/FIELDimageR/blob/master/README.md)


```{r}
img.index <- fieldIndex(mosaic = plot_crop_idx_1, index = c("BI", "GLI", "HI", "NGRDI", "BGI", "VARI", "SCI")) 
#> [1] "4 layers available"
```



```{r}
plot(img.index$NGRDI)
```


## Removing the soil
* The R package `FIELDimageR` will be used to perform this step.
* Choosing the best index to build a mask for RGB
* This is a trick analysis to run, but this criteria is up to the research to pick one threshold and VIs


```{r}
EX.Mask1 <- fieldMask(mosaic = plot_crop_idx_1, index = "NGRDI", cropValue = 0.05, cropAbove = F)
#> [1] "4 layers available"
```


```{r}

EX.Mask3 <- fieldMask(mosaic = plot_crop_idx_1, index = "HI", cropValue = 0.6, cropAbove = T) #all values above the cropValue will be accounted to make the mask.
#> [1] "4 layers available"
```


```{r}

EX.Mask4 <- fieldMask(mosaic = plot_crop_idx_1, index = "HI", cropValue = 0.8, cropAbove = T)
#> [1] "4 layers available"
```


```{r}
EX.Mask5 <- fieldMask(mosaic = plot_crop_idx_1, index = "HI", cropValue = 0.6, cropAbove = T) ## This model will be select to perform the analysis
#> [1] "4 layers available"
```


##  Building vegetation indices


```{r}
#Investigating the raw image plot
img.index.hi <- fieldIndex(mosaic = plot_crop_idx_1, index = c("HI") )
#> [1] "4 layers available"
```



```{r}
hist(img.index.hi$HI) # Image segmentation start from 0.7 (soil and plants)
```


```{r}

#Investigating the clean image plot
img.index.hi.clean <- fieldIndex(mosaic = EX.Mask5$newMosaic, index = c("HI") )
#> [1] "4 layers available"
```



```{r}
hist(img.index.hi.clean$HI) # Image segmentation start from 0.7 (soil and plants)
```

## Orthomosaic image


```{r}
ortho.index.hi.clean<- fieldIndex(mosaic = img.rgb.1, index = c("HI"))
#> [1] "4 layers available"
```


```{r}
#dev.off()

ortho.HI.RemSoil<- fieldMask(mosaic = img.rgb.1, Red = 1, Green = 2, Blue = 3, 
                   index = "HI", cropValue = 0.7, cropAbove = T) 
#> [1] "4 layers available"
```


## Extracting the pixels values


```{r}

##Selection the VI from the clean orthomosaic
Veg.Indices<-fieldIndex(mosaic = ortho.HI.RemSoil$newMosaic,
                        index=c("GLI"))
#> [1] "4 layers available"
```



```{r}

## Read the plots Shapefile
indPlots <- readOGR(dsn = folder_shp, layer = layer_prefix_shp)
#indPlots <- read_sf(dsn = folder_shp, layer = layer_prefix_shp)

## Conf. the CRS projections
projection(indPlots)<-projection(Veg.Indices) ##Makes coordinate system of .tif with indices and without soil and .shp the same


ortho.Info1<-fieldInfo(mosaic=Veg.Indices,
                     fieldShape=indPlots,
                     n.core=10) ## Extracts all vegetation indices (layers) for each .shp file
#> [1] "Extracting: 5 layers."
#> [1] "You can speed up this step using n.core=12 or less."

VI_data<- dplyr::as_tibble(ortho.Info1$fieldShape@data)

write.csv(VI_data, "VI_data_GLI.csv",  row.names=F) 

hist(ortho.Info1$fieldShape$GLI)
```




```{r}
#names(indPlots)
### Interpolating colors: c("white","black")
fieldPlot(fieldShape=ortho.Info1$fieldShape,fieldAttribute="MaturityDa", mosaic=Veg.Indices, color=c("white","black"), alpha = 0.5)

### Interpolating colors: c("red","blue")
fieldPlot(fieldShape=ortho.Info1$fieldShape,fieldAttribute="GLI", mosaic=Veg.Indices, color=c("red","blue"), alpha = 0.5)
```


---------------------------------------------

# Getting started - Complete data set

This code will run across of 4 type of loops:
* Flgith date (orthomosaic) **i**
* Vegetation index (VIs) **v**
* Function of pixel value extraction **f**
* Plot ID **p**

**ATTENTION**
- This script will run using the [parallel function](https://stat.ethz.ch/R-manual/R-devel/library/parallel/doc/parallel.pdf) to improve the computer capacity, however, be aware that you computer will be dedicated only for this analysis. To avoid any crash, reduce the number of cores to -2 from your total number. \n
\n


## Setting up the working directory 

```{r}
rm(list=ls())
my.path <- dirname(rstudioapi::getActiveDocumentContext()$path)
setwd(my.path)
```

# Setting the work directories

## Folder directory containing the orthomosaics

```{r}
dir_ortho <- "/MOSAIC"
dir_ortho <- paste(my.path,dir_ortho, sep="")
print(dir_ortho)
```

## Folder directory containing the shapefiles

```{r}
folder_shp <- "./Shapefile"
```

# Getting the files

```{r}
imgFiles <-list.files(path = dir_ortho, pattern="*.tif$",full.names = T) #get the Orthosaics. 
imgFiles #Files that their name ends in group1.tif (Change all file names to otimization)
#> [1] "G:\\Shared drives\\Bean_Lab\\Volpato\\R_script\\Example_drone_data_soy/WA_2018_08_15.tif"
#> [2] "G:\\Shared drives\\Bean_Lab\\Volpato\\R_script\\Example_drone_data_soy/WA_2018_08_23.tif"

imgFiles_name <-list.files(path = dir_ortho, pattern="*.tif$") # Aux file names
imgFiles_name <- gsub(".tif", "", imgFiles_name, ignore.case = FALSE, perl = FALSE, fixed = TRUE, useBytes = FALSE) # Removing the extension
imgFiles_name
#> [1] "WA_2018_08_15" "WA_2018_08_23"
```


# Loading and Reading the plots Shapefile

```{r}
# Loading the shape files
layer_prefix_shp <- "Export_Output" # name with the .shp extension
## Read the plots Shapefile
#indPlots <- readOGR(dsn = folder_shp, layer = layer_prefix_shp)
indPlots <- readOGR( folder_shp, layer = layer_prefix_shp)
#> OGR data source with driver: ESRI Shapefile 
#> Source: "G:\Shared drives\Bean_Lab\Volpato\R_script\Example_drone_data_soy", layer: "Export_Output"
#> with 48 features
#> It has 9 fields
## Polygon plot ID list from the shapefiles
names(indPlots)
#> [1] "Range2"     "Row2"       "Test"       "Entry"      "MNPlot"     "RM"        
#> [7] "RM_list"    "RepNo"      "MaturityDa"


# Subsetting plots to speed up the loop
indPlots<- indPlots[1:5,"MNPlot"]
indPlots
#> class       : SpatialPolygonsDataFrame 
#> features    : 5 
#> extent      : 457931.5, 457944.5, 4880257, 4880261  (xmin, xmax, ymin, ymax)
#> crs         : +proj=utm +zone=15 +datum=WGS84 +units=m +no_defs 
#> variables   : 1
#> names       : MNPlot 
#> min values  : 264001 
#> max values  : 264033
```

# Setting the parameters from the loop

## Plots ID

```{r}
## Data frame with plot names
Plot_ID<- as.data.frame(indPlots[,"MNPlot"])
indPlots # Plot identification propose
#> class       : SpatialPolygonsDataFrame 
#> features    : 5 
#> extent      : 457931.5, 457944.5, 4880257, 4880261  (xmin, xmax, ymin, ymax)
#> crs         : +proj=utm +zone=15 +datum=WGS84 +units=m +no_defs 
#> variables   : 1
#> names       : MNPlot 
#> min values  : 264001 
#> max values  : 264033
```

## VIs list
* The VIs list will be imported from a separated R script in order to the script maximization

```{r}
## Import the functions file
source("VIs_RGB-aux.R")

#Reading 38 VIs from RGB image
myIndex_list<- myIndex_list
myIndex_list_name<- myIndex_list_name
```

## Functions of extractions

```{r}
func_list<- c('mean', 'median','sd')
# There are many other functions (SD, VAR, Quantiles, etc)
```


## Starting the parallel function
Please, take your time and study how this function works and if this function is for you.


```{r}
gc() #Cleaning unusual memmory
#>           used  (Mb) gc trigger  (Mb) max used  (Mb)
#> Ncells 4656148 248.7    8556108 457.0  6793720 362.9
#> Vcells 6972624  53.2   27730724 211.6 54136618 413.1

# Number of cores
n.core<-detectCores() # or detectCores()

# Starting parallel
cl <- makeCluster(n.core, output = "")
registerDoParallel(cl)
getDoParWorkers()
#> [1] 12
```


## Running the loops

- This loop can take up to 5* min to complete
- * See the computer resources restrictions
```{r}
## Using the code inside the system time to get the total time used.
system.time(
  for(i in 1:length(imgFiles)){ #loop through images

    message("Processing ortho: ",paste(imgFiles_name[i]))
    #i.h<-aggregate(stack(imgFiles[k]), fact=aggregateCells) to reduce the image size if the case
    i.h <-  stack(imgFiles[i])
   
    for(v in 1:length(myIndex_list)){ #loop through VIs
  
      message("Using VI: ",paste(myIndex_list_name[v]))
      
      for(f in 1:length(func_list)){  #loop through extractions functions
       
        message("Using function: ",paste(func_list[f]))
      
  results<- foreach(p = 1:length(indPlots),  #loop through plots numbers
                     .packages = c("raster", "FIELDimageR"), 
                     .combine = rbind) %dopar% {
                      
    # Step 1: crop the plot from the orthomosaci
    h.c <-  crop(i.h, extent(indPlots[p,]))
    
    # Step 2: remove the soil using the HUE VI with a threshold = 0.6
    m.h <-  fieldMask(mosaic=h.c,
                           Red=1,
                           Green=2,
                           Blue=3,
                           index="HUE",
                           cropValue=0.6, #or 0.6 | 0.8
                           cropAbove=T, ## Removes any instance of soil from tif file
                           plot = FALSE) 
    
    # Step 3: Obtain the VI from the vegetation only
    Veg.Indices<-fieldIndex(mosaic = m.h$newMosaic, myIndex=myIndex_list[v],
    plot = FALSE)
    
    projection(indPlots)<-projection(Veg.Indices)
    
    # Step 4: Extraction the pixel value from each individual plot using the function 
     raster::extract(x = Veg.Indices$myIndex, y = indPlots[p,], fun = eval(parse(text = func_list[f])),  
            buffer = buffer, na.rm = T, df = T)
     
                     }
  
       results$Func<-func_list[f]
  
    # Step 5: Saving the results into a data frame with the lenght of the Plots ID
       results$ID <- 1:length(indPlots)
  
  if(f==1){results.1<-results}else{results.1<-rbind(results.1, results)}
  
      }
      
    # Step 6: Saving the vegetation index name for each function
      results.1$VIs<-myIndex_list_name[v]
  
     if(v==1){results.2<-results.1}else{results.2<-rbind(results.2, results.1)}

    }
    
    # # Step 6: Saving the vegetation index name from each function for each orthomosaic
      results.2$imgFiles_name<-imgFiles_name[i]
      
        if(i==1){results.3<-results.2}else{results.3<-rbind(results.3, results.2)}
    
  })
#>    user  system elapsed 
#>    2.48    0.42  307.19

parallel::stopCluster(cl) # Stopping the parallel function


###### the end ###########
```



## Adjusting the results and saving

```{r}
as_tibble(results.3) # Saving into a table
#> # A tibble: 760 x 5
#>       ID myIndex Func   VIs       imgFiles_name
#>    <int>   <dbl> <chr>  <list>    <chr>        
#>  1     1    115. mean   <chr [1]> WA_2018_08_15
#>  2     2    118. mean   <chr [1]> WA_2018_08_15
#>  3     3    119. mean   <chr [1]> WA_2018_08_15
#>  4     4    120. mean   <chr [1]> WA_2018_08_15
#>  5     5    134. mean   <chr [1]> WA_2018_08_15
#>  6     1    114. median <chr [1]> WA_2018_08_15
#>  7     2    116. median <chr [1]> WA_2018_08_15
#>  8     3    118. median <chr [1]> WA_2018_08_15
#>  9     4    120. median <chr [1]> WA_2018_08_15
#> 10     5    134. median <chr [1]> WA_2018_08_15
#> # ... with 750 more rows

# Adjusting the data for VIs and Func columns
results.final<-tidyr::pivot_wider(results.3, names_from   = c("VIs", "Func"),
                           values_from = "myIndex")

head(results.final)
#> # A tibble: 6 x 78
#>      ID imgFiles_name BI_mean BI_median BIM_mean BIM_median SCI_mean SCI_median GLI_mean
#>   <int> <chr>           <dbl>     <dbl>    <dbl>      <dbl>    <dbl>      <dbl>    <dbl>
#> 1     1 WA_2018_08_15    115.      114.     14.8       14.8  -0.0705    -0.0758    0.200
#> 2     2 WA_2018_08_15    118.      116.     15.0       14.9  -0.0606    -0.0671    0.190
#> 3     3 WA_2018_08_15    119.      118.     15.1       15.1  -0.0503    -0.0554    0.179
#> 4     4 WA_2018_08_15    120.      120.     15.2       15.2  -0.0517    -0.0576    0.172
#> 5     5 WA_2018_08_15    134.      134.     16.2       16.2  -0.0197    -0.0175    0.130
#> 6     1 WA_2018_08_23    120.      119.     15.2       15.2  -0.0564    -0.0580    0.173
#> # ... with 69 more variables: GLI_median <dbl>, HI_mean <dbl>, HI_median <dbl>,
#> #   NGRDI_mean <dbl>, NGRDI_median <dbl>, SI_mean <dbl>, SI_median <dbl>,
#> #   VARI_mean <dbl>, VARI_median <dbl>, HUE_mean <dbl>, HUE_median <dbl>,
#> #   BdivG_mean <dbl>, BdivG_median <dbl>, BCC_mean <dbl>, BCC_median <dbl>,
#> #   CIVE_mean <dbl>, CIVE_median <dbl>, COM1_mean <dbl>, COM1_median <dbl>,
#> #   COM2_mean <dbl>, COM2_median <dbl>, ExG_mean <dbl>, ExG_median <dbl>,
#> #   ExG2_mean <dbl>, ExG2_median <dbl>, ExGR_mean <dbl>, ExGR_median <dbl>, ...

# Saving
write.csv(results.final, "test01_MRF_RGB.csv", quote = F, row.names = F)
```


---------------------------------------------
























